/*
 Copyright 2015 Red Hat, Inc. and/or its affiliates.

 This file is part of lightblue.

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.redhat.lightblue.crud;

import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ContainerNode;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.redhat.lightblue.metadata.ArrayField;
import com.redhat.lightblue.metadata.EntityMetadata;
import com.redhat.lightblue.metadata.FieldCursor;
import com.redhat.lightblue.metadata.FieldTreeNode;
import com.redhat.lightblue.metadata.Fields;
import com.redhat.lightblue.metadata.ObjectArrayElement;
import com.redhat.lightblue.metadata.ObjectField;
import com.redhat.lightblue.metadata.PredefinedFields;
import com.redhat.lightblue.metadata.types.IntegerType;
import com.redhat.lightblue.metadata.types.StringType;
import com.redhat.lightblue.util.Path;

/**
 * When a datasource does not store fields automatically generated by Lightblue, this extension of
 * {@link TranslatorToJson} will ensure that the fields and values are present.
 *
 * @author dcrissman
 *
 * @param <S>
 */
public abstract class NonPersistedPredefinedFieldTranslatorToJson<S> extends TranslatorToJson<S>{

    /** Holding bin for the currently relevant {@link Fields}. */
    private Fields currentFields;
    /** Holding bin for the currently relevant {@link ObjectNode}. */
    private ObjectNode currentTargetObjectNode;

    public NonPersistedPredefinedFieldTranslatorToJson(JsonNodeFactory factory,
            EntityMetadata entityMetadata) {
        super(factory, entityMetadata);
        currentFields = entityMetadata.getFields();
    }

    @Override
    protected void appendToJsonNode(Object value, ContainerNode<?> targetNode, FieldCursor cursor) {
        FieldTreeNode field = cursor.getCurrentNode();

        if(PredefinedFields.isFieldAnArrayCount(field.getName(), currentFields)){
            /*
             * This case will be handled by the array itself, allowing this to
             * process runs the risk of nulling out the correct value.
             */
            return;
        }

        Path fieldPath = cursor.getCurrentPath();
        if (targetNode instanceof ObjectNode) {
            currentTargetObjectNode = (ObjectNode) targetNode;
        }

        if(PredefinedFields.isFieldObjectType(fieldPath.toString())){
            ((ObjectNode) targetNode).set(fieldPath.toString(), toJson(StringType.TYPE, entityMetadata.getEntityInfo().getName()));
        }
        else{
            super.appendToJsonNode(value, targetNode, cursor);
        }

    }

    @Override
    ArrayNode translateToArrayNode(ArrayField field, Object value, FieldCursor cursor) {
        currentTargetObjectNode.set(
            PredefinedFields.createArrayCountFieldName(field.getName()),
            toJson(IntegerType.TYPE, getSizeOf(value)));
        return super.translateToArrayNode(field, value, cursor);
    }

    @Override
    ObjectNode translateToObjectNode(Object value, FieldCursor cursor) {
        FieldTreeNode field = cursor.getCurrentNode();

        //Store the current fields so that they can be put back after this operation is complete.
        Fields storeFieldsUntilLater = currentFields;
        if (field instanceof ObjectField) {
            currentFields = ((ObjectField) field).getFields();
        }
        else if (field instanceof ObjectArrayElement) {
            currentFields = ((ObjectArrayElement) field).getFields();
        }
        else {
            throw new IllegalArgumentException("Only Object Field/Element types are supported: " + field.getClass());
        }

        ObjectNode node = super.translateToObjectNode(value, cursor);

        currentFields = storeFieldsUntilLater;

        return node;
    }

    protected abstract int getSizeOf(Object o);

}
